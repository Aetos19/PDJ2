# The next time you run your program, Python will load the .pyc files and skip the compilation step, as long as you haven’t changed your source code since the byte code was last saved.

# That byte code is saved in files only for files that are imported, not for the top-level files of a program that are only run as scripts

# Python programs into true executables, known as frozen binaries in the Python world. These programs can be run without equiring a Python installation.

# An attribute is simply a variable name that is attached to a specific object (like a module).

Q) Why might you need to reload a module?

A) Python imports (loads) a module only once per process, by default, so if you’ve changed its source code and want to run the new version without stopping and restarting Python, you’ll have to reload it. You must import a module at least once before you can reload it.

Q) What is a namespace, and how does it relate to module files?

A) A namespace is just a package of variables (i.e., names). It takes the form of an object with attributes in Python. Each module file is automatically a namespace— that is, a package of variables reflecting the assignments made at the top level of the file. Namespaces help avoid name collisions in Python programs: because each module file is a self-contained namespace, files must explicitly import other files in order to use their names.

	$ B = bytearray(b'eggs')
	$ B.extend(b'spam')
	$ B.decode() # Translate to normal string

# repr('spam') >> # Used by echoes: as-code form
	"'spam'"
# str('spam')  >> # # Used by print: user-friendly form
	'spam'

# floor >> Closest number below value

# trunc >> Truncate fractional part (toward zero)

# a.bit_length() or len(bin(a)) - 2

**** from decimal import Decimal ****

	>>> print 0.1+0.1+0.1-0.3
	5.551115123e-17

	>>> Decimal('0.1')+Decimal('0.1')+Decimal('0.1')-Decimal('0.3')
	Decimal('0.0')

	Decimal(1)/Decimal(4) # Default: 28 digits

	$ decimal.getcontext().prec = 4

**** from fractions import Fraction ****
	x = Fraction(1, 3)
	y = Fraction(2, 3)

# Once created, Fraction s can be used in mathematical expressions as usual:

	$ x + y >>> Fraction(1, 1)

# Fraction objects can also be created from floating-point number strings.

	$ Fraction('0.25') >>> Fraction(1, 4)

# Moreover, fractions and decimals both allow more intuitive and accurate results than floating points sometimes can

# >>> x > y, x < y  >>> # Superset, subset
(False, False) 

# Sets can be used to isolate differences in lists, strings, and other iterable objects too—
# simply convert to sets and take the difference

>>> set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6])  # Find list differences
{3, 7}

# You can also use sets to perform order-neutral equality tests by converting to a set before the test, because order doesn’t matter in a set.

>>> L1, L2 = [1, 3, 5, 2, 4], [2, 5, 3, 4, 1]
>>> L1 == L2  # Order matters in sequences
False

>>> set(L1) == set(L2) # Order-neutral equality
True

# engineers > managers # Are all managers engineers? (superset)

# These steps reflect the operation of all assignments in the Python language:
	1. Create an object to represent the value 3 .
	2. Create the variable a , if it does not yet exist.
	3. Link the variable a to the new object 3 .

	$ l1 = [2, 3, 4]
	$ l2 = l1
	$ l1[0] = 23
	$ l1 >>> [23, 3, 4]
	$ l2 >>> [23, 3, 4]

	$ l3 = l1[:] # Make a copy of L1 (or list(L1), copy.copy(L1), etc.

	# The change made through L1 is not reflected in L2 because L2 references a copy of the object L1 references, not the original; that is, the two variables point to different pieces of memory.

import copy
X = copy.copy(Y)  # Make top-level "shallow" copy of any object Y
X = copy.deepcopy(Y)  # Make deep copy of any object Y: copy all nested parts

>>> L = [1, 2, 3]
>>> M = L	# M and L reference the same object
>>> L == M	# Same Values
True
>>> L is M	# Same objects

****************

>>> L = [1, 2, 3]
>>> M = [1, 2, 3]# M and L refernce different objects
>>> L == M	# Same Values
True
>>> L is M	# Different objects
False


# The == operator, tests whether the two referenced objects have the same values;

# The is operator, instead tests for object identity—it returns True only if both names point to the exact same object

# The "getrefcount" function in the standard sys module returns the object’s reference count.

# There are three string types: 
	str is used for Unicode text (including ASCII),
	bytes is used for binary data (including encoded text),
	bytearray is a mutable variant of bytes .

	>>> title = "Meaning " 'of' " Life"	# Implicit concatenation
	>>> title
	'Meaning of Life'

# 














